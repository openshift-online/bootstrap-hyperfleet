#!/bin/bash
set -euo pipefail

# AWS Comprehensive Resource Discovery by Relationships
# 
# Discovers ALL AWS resources consumed by a cluster by following dependency 
# relationships through IDs, not just tags. Finds orphaned resources that 
# lack proper tagging but are connected to cluster infrastructure.
#
# Complete AWS Resource Dependency Hierarchy (Top-Down Discovery):
#
# LEVEL 0 (ROOT): VPC + Global Resources
#   â”œâ”€â”€ VPCs (tagged with cluster)
#   â”œâ”€â”€ IAM Roles/Policies (tagged with cluster) 
#   â””â”€â”€ S3 Buckets (tagged with cluster)
#
# LEVEL 1 (VPC-SCOPED): Core Infrastructure  
#   â”œâ”€â”€ Subnets â†’ all subnets in cluster VPCs
#   â”œâ”€â”€ Security Groups â†’ all groups in cluster VPCs
#   â”œâ”€â”€ Route Tables â†’ all tables in cluster VPCs  
#   â”œâ”€â”€ Internet/NAT Gateways â†’ attached to cluster VPCs
#   â””â”€â”€ VPC Endpoints â†’ deployed in cluster VPCs
#
# LEVEL 2 (SUBNET-SCOPED): Deployed Services
#   â”œâ”€â”€ EC2 Instances â†’ deployed in cluster subnets
#   â”œâ”€â”€ RDS Instances â†’ deployed in cluster subnets  
#   â”œâ”€â”€ ELB/ALB â†’ deployed in cluster subnets
#   â”œâ”€â”€ EFS Mount Targets â†’ deployed in cluster subnets
#   â””â”€â”€ Network Interfaces â†’ deployed in cluster subnets
#
# LEVEL 3 (INSTANCE-SCOPED): Attached Resources
#   â”œâ”€â”€ EBS Volumes â†’ attached to cluster EC2 instances
#   â”œâ”€â”€ EBS Snapshots â†’ from cluster EBS volumes
#   â”œâ”€â”€ Elastic IPs â†’ attached to cluster instances/ENIs
#   â””â”€â”€ Auto Scaling Groups â†’ managing cluster instances
#
# LEVEL 4 (SERVICE-SCOPED): Service Resources
#   â”œâ”€â”€ Target Groups â†’ attached to cluster ELBs
#   â”œâ”€â”€ Launch Templates â†’ used by cluster ASGs
#   â”œâ”€â”€ EFS File Systems â†’ mounted in cluster
#   â””â”€â”€ CloudFormation Stacks â†’ created for cluster
#
# OUTPUT FORMAT: Compatible with aws-clean-resources for seamless workflow

# Parse command line arguments
DEBUG=${DEBUG:-false}
ALL_REGIONS=false
VERBOSE=false

for arg in "$@"; do
    case $arg in
        --debug)
            DEBUG=true
            set -x
            ;;
        --all-regions)
            ALL_REGIONS=true
            ;;
        --verbose)
            VERBOSE=true
            ;;
        --help)
            echo "Usage: $0 [CLUSTER_ID] [OPTIONS]"
            echo ""
            echo "DISCOVERY STRATEGY:"
            echo "  Comprehensive relationship-based discovery - follows AWS resource dependencies"
            echo "  through IDs to find ALL cluster resources, including those with missing tags"
            echo ""
            echo "OPTIONS:"
            echo "  --debug         Enable debug output with discovery strategy details"
            echo "  --all-regions   Search all supported regions"
            echo "  --verbose       Show discovery progress to stderr"
            echo "  --help          Show this help"
            echo ""
            echo "Examples:"
            echo "  $0 ocp-02                    # Discover resources for ocp-02"
            echo "  $0 eks-02 --all-regions     # Search all regions"
            echo "  $0 ocp-03 --verbose         # Show progress + JSON output"
            exit 0
            ;;
    esac
done

debug_log() {
    if [[ "$DEBUG" == "true" ]]; then
        echo "[DEBUG $(date '+%H:%M:%S')] $*" >&2
    fi
}

verbose_log() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "[INFO] $*" >&2
    fi
}

# Set defaults for cluster ID and regions
DEFAULT_CLUSTER_ID="ocp-02"
DEFAULT_REGIONS=("us-west-2")
ALL_SUPPORTED_REGIONS=("us-east-1" "us-east-2" "us-west-2" "eu-west-1" "ap-southeast-1")

# Get cluster ID from first non-option argument
CLUSTER_ID=""
for arg in "$@"; do
    if [[ ! "$arg" =~ ^-- ]]; then
        CLUSTER_ID="$arg"
        break
    fi
done

CLUSTER_ID="${CLUSTER_ID:-$DEFAULT_CLUSTER_ID}"

# Set regions based on options
if [[ "$ALL_REGIONS" == "true" ]]; then
    REGIONS=("${ALL_SUPPORTED_REGIONS[@]}")
else
    REGIONS=("${DEFAULT_REGIONS[@]}")
fi

debug_log "Cluster ID: '$CLUSTER_ID'"
debug_log "Regions: ${REGIONS[*]}"

# Main discovery loop - only process one region for now (simplicity)
REGION="${REGIONS[0]}"

if [[ "$VERBOSE" == "true" ]]; then
    echo "=== AWS Comprehensive Resource Discovery ===" >&2
    echo "Discovering ALL resources for cluster: $CLUSTER_ID" >&2
    echo "Region: $REGION" >&2
    echo "Following ID relationships to find connected resources..." >&2
    echo "" >&2
fi

debug_log "Beginning relationship-based discovery for region: $REGION"

#==============================================================================
# LEVEL 0 (ROOT): VPC + Global Resources - Tagged cluster entry points
#==============================================================================

# Find VPCs belonging to cluster via tags (primary entry point)
find_cluster_vpcs() {
    local cluster_id="$1"
    local region="$2"
    
    verbose_log "Finding cluster VPCs for $cluster_id..."
    
    aws ec2 describe-vpcs --region "$region" \
        --filters "Name=tag-value,Values=*${cluster_id}*" \
        --query 'Vpcs[*].VpcId' --output text 2>/dev/null || echo ""
}

# Find IAM roles belonging to cluster via tags (global)
find_cluster_iam_roles() {
    local cluster_id="$1"
    
    verbose_log "Finding cluster IAM roles for $cluster_id..."
    
    aws iam list-roles \
        --query "Roles[?contains(RoleName, '${cluster_id}')].[RoleName,Arn,CreateDate,Description,RoleName]" \
        --output json 2>/dev/null || echo "[]"
}

# Find IAM policies belonging to cluster via tags (global)
find_cluster_iam_policies() {
    local cluster_id="$1"
    
    verbose_log "Finding cluster IAM policies for $cluster_id..."
    
    aws iam list-policies --scope Local \
        --query "Policies[?contains(PolicyName, '${cluster_id}')].[PolicyName,Arn,CreateDate,Description,PolicyName]" \
        --output json 2>/dev/null || echo "[]"
}

# Find S3 buckets belonging to cluster via tags (global)
find_cluster_s3_buckets() {
    local cluster_id="$1"
    
    verbose_log "Finding cluster S3 buckets for $cluster_id..."
    
    aws s3api list-buckets \
        --query "Buckets[?contains(Name, '${cluster_id}')].[Name,CreationDate]" \
        --output json 2>/dev/null || echo "[]"
}

#==============================================================================
# LEVEL 1 (VPC-SCOPED): Core Infrastructure - All resources in cluster VPCs
#==============================================================================

find_subnets_in_vpcs() {
    local vpc_ids="$1"
    local region="$2"
    
    [[ -z "$vpc_ids" || "$vpc_ids" == "None" ]] && echo "[]" && return
    
    verbose_log "Finding subnets in VPCs: $vpc_ids"
    
    local vpc_filter=$(echo "$vpc_ids" | tr ' ' ',')
    
    aws ec2 describe-subnets --region "$region" \
        --filters "Name=vpc-id,Values=${vpc_filter}" \
        --query 'Subnets[*].[SubnetId,VpcId,CidrBlock,AvailabilityZone,MapPublicIpOnLaunch,Tags[?Key==`Name`].Value|[0]||`vpc-relationship`]' \
        --output json 2>/dev/null || echo "[]"
}

find_security_groups_in_vpcs() {
    local vpc_ids="$1"
    local region="$2"
    
    [[ -z "$vpc_ids" || "$vpc_ids" == "None" ]] && echo "[]" && return
    
    verbose_log "Finding security groups in VPCs: $vpc_ids"
    
    local vpc_filter=$(echo "$vpc_ids" | tr ' ' ',')
    
    aws ec2 describe-security-groups --region "$region" \
        --filters "Name=vpc-id,Values=${vpc_filter}" \
        --query 'SecurityGroups[*].[GroupId,GroupName,VpcId,Description,Tags[?Key==`Name`].Value|[0]||`vpc-relationship`]' \
        --output json 2>/dev/null || echo "[]"
}

find_route_tables_in_vpcs() {
    local vpc_ids="$1" 
    local region="$2"
    
    [[ -z "$vpc_ids" || "$vpc_ids" == "None" ]] && echo "[]" && return
    
    verbose_log "Finding route tables in VPCs: $vpc_ids"
    
    local vpc_filter=$(echo "$vpc_ids" | tr ' ' ',')
    
    aws ec2 describe-route-tables --region "$region" \
        --filters "Name=vpc-id,Values=${vpc_filter}" \
        --query 'RouteTables[*].[RouteTableId,VpcId,Associations[0].Main||false,Tags[?Key==`Name`].Value|[0]||`vpc-relationship`]' \
        --output json 2>/dev/null || echo "[]"
}

find_internet_gateways_for_vpcs() {
    local vpc_ids="$1"
    local region="$2"
    
    [[ -z "$vpc_ids" || "$vpc_ids" == "None" ]] && echo "[]" && return
    
    verbose_log "Finding internet gateways attached to VPCs: $vpc_ids"
    
    local vpc_filter=$(echo "$vpc_ids" | tr ' ' ',')
    
    aws ec2 describe-internet-gateways --region "$region" \
        --filters "Name=attachment.vpc-id,Values=${vpc_filter}" \
        --query 'InternetGateways[*].[InternetGatewayId,Attachments[0].VpcId,Attachments[0].State,Tags[?Key==`Name`].Value|[0]||`vpc-relationship`]' \
        --output json 2>/dev/null || echo "[]"
}

find_nat_gateways_in_vpcs() {
    local vpc_ids="$1"
    local region="$2"
    
    [[ -z "$vpc_ids" || "$vpc_ids" == "None" ]] && echo "[]" && return
    
    verbose_log "Finding NAT gateways in VPCs: $vpc_ids"
    
    local vpc_filter=$(echo "$vpc_ids" | tr ' ' ',')
    
    aws ec2 describe-nat-gateways --region "$region" \
        --filters "Name=vpc-id,Values=${vpc_filter}" \
        --query 'NatGateways[*].[NatGatewayId,VpcId,SubnetId,State,NatGatewayAddresses[0].PublicIp||`no-public-ip`,Tags[?Key==`Name`].Value|[0]||`vpc-relationship`]' \
        --output json 2>/dev/null || echo "[]"
}

find_vpc_endpoints_in_vpcs() {
    local vpc_ids="$1"
    local region="$2"
    
    [[ -z "$vpc_ids" || "$vpc_ids" == "None" ]] && echo "[]" && return
    
    verbose_log "Finding VPC endpoints in VPCs: $vpc_ids"
    
    local vpc_filter=$(echo "$vpc_ids" | tr ' ' ',')
    
    aws ec2 describe-vpc-endpoints --region "$region" \
        --filters "Name=vpc-id,Values=${vpc_filter}" \
        --query 'VpcEndpoints[*].[VpcEndpointId,VpcId,ServiceName,State,VpcEndpointType,Tags[?Key==`Name`].Value|[0]||`vpc-relationship`]' \
        --output json 2>/dev/null || echo "[]"
}

find_classic_elbs_in_vpcs() {
    local vpc_ids="$1"
    local region="$2"
    
    [[ -z "$vpc_ids" || "$vpc_ids" == "None" ]] && echo "[]" && return
    
    verbose_log "Finding classic ELBs in VPCs: $vpc_ids"
    
    local vpc_filter=$(echo "$vpc_ids" | tr ' ' ',')
    
    aws elb describe-load-balancers --region "$region" \
        --query "LoadBalancerDescriptions[?contains(['${vpc_filter//,/\',\'}'], VPCId)].[LoadBalancerName,VPCId,Scheme,CreatedTime,LoadBalancerName]" \
        --output json 2>/dev/null || echo "[]"
}

find_application_elbs_in_vpcs() {
    local vpc_ids="$1"
    local region="$2"
    
    [[ -z "$vpc_ids" || "$vpc_ids" == "None" ]] && echo "[]" && return
    
    verbose_log "Finding application ELBs in VPCs: $vpc_ids"
    
    local vpc_filter=$(echo "$vpc_ids" | tr ' ' ',')
    
    aws elbv2 describe-load-balancers --region "$region" \
        --query "LoadBalancers[?contains(['${vpc_filter//,/\',\'}'], VpcId)].[LoadBalancerArn,LoadBalancerName,Type,State.Code,VpcId,LoadBalancerName]" \
        --output json 2>/dev/null || echo "[]"
}

#==============================================================================
# LEVEL 2 (SUBNET-SCOPED): Deployed Services - Resources deployed in cluster subnets
#==============================================================================

find_network_interfaces_in_subnets() {
    local subnet_ids="$1"
    local region="$2"
    
    [[ -z "$subnet_ids" || "$subnet_ids" == "[]" ]] && echo "[]" && return
    
    verbose_log "Finding network interfaces in cluster subnets"
    
    local subnet_filter
    subnet_filter=$(echo "$subnet_ids" | jq -r '.[][] | select(type == "array") | .[0]' | tr '\n' ',' | sed 's/,$//')
    
    [[ -z "$subnet_filter" ]] && echo "[]" && return
    
    aws ec2 describe-network-interfaces --region "$region" \
        --filters "Name=subnet-id,Values=${subnet_filter}" \
        --query 'NetworkInterfaces[*].[NetworkInterfaceId,InterfaceType,Status,VpcId,SubnetId,PrivateIpAddress,Attachment.InstanceId||`unattached`,Tags[?Key==`Name`].Value|[0]||`subnet-relationship`]' \
        --output json 2>/dev/null || echo "[]"
}

find_ec2_instances_in_subnets() {
    local subnet_ids="$1"
    local region="$2"
    
    [[ -z "$subnet_ids" || "$subnet_ids" == "[]" ]] && echo "[]" && return
    
    verbose_log "Finding EC2 instances in cluster subnets"
    
    local subnet_filter
    subnet_filter=$(echo "$subnet_ids" | jq -r '.[][] | select(type == "array") | .[0]' | tr '\n' ',' | sed 's/,$//')
    
    [[ -z "$subnet_filter" ]] && echo "[]" && return
    
    aws ec2 describe-instances --region "$region" \
        --filters "Name=subnet-id,Values=${subnet_filter}" \
                  "Name=instance-state-name,Values=running,stopped,stopping,pending" \
        --query 'Reservations[*].Instances[*].[InstanceId,InstanceType,State.Name,VpcId,SubnetId,PrivateIpAddress,Tags[?Key==`Name`].Value|[0]||`subnet-relationship`]' \
        --output json 2>/dev/null || echo "[]"
}

find_rds_instances_in_subnets() {
    local subnet_ids="$1"
    local region="$2"
    
    [[ -z "$subnet_ids" || "$subnet_ids" == "[]" ]] && echo "[]" && return
    
    verbose_log "Finding RDS instances in cluster subnets"
    
    local subnet_filter
    subnet_filter=$(echo "$subnet_ids" | jq -r '.[][] | select(type == "array") | .[0]' | tr '\n' ',' | sed 's/,$//')
    
    [[ -z "$subnet_filter" ]] && echo "[]" && return
    
    # First find DB subnet groups using our subnets
    local db_subnet_groups
    db_subnet_groups=$(aws rds describe-db-subnet-groups --region "$region" \
        --query "DBSubnetGroups[?Subnets[?contains(['${subnet_filter//,/\',\'}'], SubnetIdentifier)]].DBSubnetGroupName" \
        --output text 2>/dev/null | tr '\t' ',')
    
    [[ -z "$db_subnet_groups" ]] && echo "[]" && return
    
    # Then find RDS instances using those subnet groups
    aws rds describe-db-instances --region "$region" \
        --query "DBInstances[?contains(['${db_subnet_groups//,/\',\'}'], DBSubnetGroup.DBSubnetGroupName)].[DBInstanceIdentifier,DBInstanceStatus,DBInstanceClass,Engine,DBSubnetGroup.VpcId,DBInstanceIdentifier]" \
        --output json 2>/dev/null || echo "[]"
}

find_efs_mount_targets_in_subnets() {
    local subnet_ids="$1"  
    local region="$2"
    
    [[ -z "$subnet_ids" || "$subnet_ids" == "[]" ]] && echo "[]" && return
    
    verbose_log "Finding EFS mount targets in cluster subnets"
    
    local subnet_filter
    subnet_filter=$(echo "$subnet_ids" | jq -r '.[][] | select(type == "array") | .[0]' | tr '\n' ',' | sed 's/,$//')
    
    [[ -z "$subnet_filter" ]] && echo "[]" && return
    
    aws efs describe-mount-targets --region "$region" \
        --query "MountTargets[?contains(['${subnet_filter//,/\',\'}'], SubnetId)].[MountTargetId,FileSystemId,SubnetId,LifeCycleState,IpAddress,FileSystemId]" \
        --output json 2>/dev/null || echo "[]"
}

#==============================================================================
# LEVEL 3 (INSTANCE-SCOPED): Attached Resources - Resources attached to instances
#==============================================================================

find_ebs_volumes_for_instances() {
    local ec2_instances="$1"
    local region="$2"
    
    [[ -z "$ec2_instances" || "$ec2_instances" == "[]" ]] && echo "[]" && return
    
    verbose_log "Finding EBS volumes attached to cluster instances"
    
    local instance_filter  
    instance_filter=$(echo "$ec2_instances" | jq -r '.[][] | select(type == "array") | .[0]' | tr '\n' ',' | sed 's/,$//')
    
    [[ -z "$instance_filter" ]] && echo "[]" && return
    
    aws ec2 describe-volumes --region "$region" \
        --filters "Name=attachment.instance-id,Values=${instance_filter}" \
        --query 'Volumes[*].[VolumeId,Size,VolumeType,State,Encrypted,Attachments[0].InstanceId,Iops||`0`,Tags[?Key==`Name`].Value|[0]||`instance-attachment`]' \
        --output json 2>/dev/null || echo "[]"
}

find_ebs_snapshots_for_volumes() {
    local ebs_volumes="$1"
    local region="$2" 
    
    [[ -z "$ebs_volumes" || "$ebs_volumes" == "[]" ]] && echo "[]" && return
    
    verbose_log "Finding EBS snapshots from cluster volumes"
    
    local volume_filter
    volume_filter=$(echo "$ebs_volumes" | jq -r '.[][] | select(type == "array") | .[0]' | tr '\n' ',' | sed 's/,$//')
    
    [[ -z "$volume_filter" ]] && echo "[]" && return
    
    aws ec2 describe-snapshots --region "$region" \
        --owner-ids self \
        --filters "Name=volume-id,Values=${volume_filter}" \
        --query 'Snapshots[*].[SnapshotId,VolumeSize,State,StartTime,Description,Tags[?Key==`Name`].Value|[0]||`volume-relationship`]' \
        --output json 2>/dev/null || echo "[]"
}

find_elastic_ips_for_instances() {
    local ec2_instances="$1"
    local network_interfaces="$2"
    local region="$3"
    
    verbose_log "Finding Elastic IPs attached to cluster resources"
    
    local instance_ids eni_ids
    instance_ids=$(echo "$ec2_instances" | jq -r '.[][] | select(type == "array") | .[0]' | tr '\n' ',' | sed 's/,$//')
    eni_ids=$(echo "$network_interfaces" | jq -r '.[][] | select(type == "array") | .[0]' | tr '\n' ',' | sed 's/,$//')
    
    local all_eips="[]"
    if [[ -n "$instance_ids" ]]; then
        local instance_eips
        instance_eips=$(aws ec2 describe-addresses --region "$region" \
            --filters "Name=instance-id,Values=${instance_ids}" \
            --query 'Addresses[*].[AllocationId,PublicIp,InstanceId||`unassociated`,NetworkInterfaceId||`none`,Domain,Tags[?Key==`Name`].Value|[0]||`instance-attachment`]' \
            --output json 2>/dev/null || echo "[]")
        all_eips=$(echo "$all_eips $instance_eips" | jq -s 'add')
    fi
    
    if [[ -n "$eni_ids" ]]; then
        local eni_eips
        eni_eips=$(aws ec2 describe-addresses --region "$region" \
            --filters "Name=network-interface-id,Values=${eni_ids}" \
            --query 'Addresses[*].[AllocationId,PublicIp,InstanceId||`unassociated`,NetworkInterfaceId||`none`,Domain,Tags[?Key==`Name`].Value|[0]||`eni-attachment`]' \
            --output json 2>/dev/null || echo "[]")
        all_eips=$(echo "$all_eips $eni_eips" | jq -s 'add')
    fi
    
    echo "$all_eips"
}

find_auto_scaling_groups_for_instances() {
    local ec2_instances="$1"
    local region="$2"
    
    [[ -z "$ec2_instances" || "$ec2_instances" == "[]" ]] && echo "[]" && return
    
    verbose_log "Finding Auto Scaling Groups managing cluster instances"
    
    local instance_filter
    instance_filter=$(echo "$ec2_instances" | jq -r '.[][] | select(type == "array") | .[0]' | tr '\n' ',' | sed 's/,$//')
    
    [[ -z "$instance_filter" ]] && echo "[]" && return
    
    aws autoscaling describe-auto-scaling-groups --region "$region" \
        --query "AutoScalingGroups[?Instances[?contains(['${instance_filter//,/\',\'}'], InstanceId)]].[AutoScalingGroupName,DesiredCapacity,MinSize,MaxSize,VPCZoneIdentifier,AutoScalingGroupName]" \
        --output json 2>/dev/null || echo "[]"
}

#==============================================================================
# LEVEL 4 (SERVICE-SCOPED): Service Resources - Resources created by services
#==============================================================================

find_target_groups_for_elbs() {
    local application_elbs="$1"
    local region="$2"
    
    [[ -z "$application_elbs" || "$application_elbs" == "[]" ]] && echo "[]" && return
    
    verbose_log "Finding target groups for cluster ELBs"
    
    local elb_arns
    elb_arns=$(echo "$application_elbs" | jq -r '.[][] | select(type == "array") | .[0]' | tr '\n' ',' | sed 's/,$//')
    
    [[ -z "$elb_arns" ]] && echo "[]" && return
    
    aws elbv2 describe-target-groups --region "$region" \
        --query "TargetGroups[?LoadBalancerArns && LoadBalancerArns[?contains(['${elb_arns//,/\',\'}'], @)]].[TargetGroupArn,TargetGroupName,Protocol,Port,VpcId,TargetGroupName]" \
        --output json 2>/dev/null || echo "[]"
}

find_launch_templates_for_asgs() {
    local auto_scaling_groups="$1"
    local region="$2"
    
    [[ -z "$auto_scaling_groups" || "$auto_scaling_groups" == "[]" ]] && echo "[]" && return
    
    verbose_log "Finding launch templates for cluster ASGs"
    
    # Extract launch template IDs from ASG configurations
    local asg_names
    asg_names=$(echo "$auto_scaling_groups" | jq -r '.[][] | select(type == "array") | .[0]' | tr '\n' ',' | sed 's/,$//')
    
    [[ -z "$asg_names" ]] && echo "[]" && return
    
    # Get launch template details for each ASG
    aws autoscaling describe-auto-scaling-groups --region "$region" \
        --auto-scaling-group-names $(echo "$asg_names" | tr ',' ' ') \
        --query 'AutoScalingGroups[*].LaunchTemplate.[LaunchTemplateId,LaunchTemplateName,Version,"asg-relationship"]' \
        --output json 2>/dev/null || echo "[]"
}

find_efs_filesystems_for_mount_targets() {
    local mount_targets="$1"
    local region="$2"
    
    [[ -z "$mount_targets" || "$mount_targets" == "[]" ]] && echo "[]" && return  
    
    verbose_log "Finding EFS file systems for cluster mount targets"
    
    local filesystem_ids
    filesystem_ids=$(echo "$mount_targets" | jq -r '.[][] | select(type == "array") | .[1]' | sort -u | tr '\n' ',' | sed 's/,$//')
    
    [[ -z "$filesystem_ids" ]] && echo "[]" && return
    
    aws efs describe-file-systems --region "$region" \
        --file-system-ids $(echo "$filesystem_ids" | tr ',' ' ') \
        --query 'FileSystems[*].[FileSystemId,Name||`no-name`,LifeCycleState,SizeInBytes.Value,CreationTime,Name||`mount-target-relationship`]' \
        --output json 2>/dev/null || echo "[]"
}

find_cloudformation_stacks_for_cluster() {
    local cluster_id="$1"
    local region="$2"
    
    verbose_log "Finding CloudFormation stacks for $cluster_id"
    
    aws cloudformation describe-stacks --region "$region" \
        --query "Stacks[?contains(StackName, '${cluster_id}')].[StackName,StackStatus,CreationTime,Description,StackName]" \
        --output json 2>/dev/null || echo "[]"
}

find_ecr_repositories_for_cluster() {
    local cluster_id="$1"
    local region="$2"
    
    verbose_log "Finding ECR repositories for $cluster_id"
    
    aws ecr describe-repositories --region "$region" \
        --query "repositories[?contains(repositoryName, '${cluster_id}')].[repositoryName,repositoryUri,createdAt,repositoryName]" \
        --output json 2>/dev/null || echo "[]"
}

#==============================================================================
# Main Discovery Engine - Orchestrates comprehensive relationship discovery
#==============================================================================
main() {
    # Step 1: Find cluster VPCs (tagged resources - our starting point)
    local cluster_vpcs
    cluster_vpcs=$(find_cluster_vpcs "$CLUSTER_ID" "$REGION")
    
    if [[ -z "$cluster_vpcs" || "$cluster_vpcs" == "None" ]]; then
        if [[ "$VERBOSE" == "true" ]]; then
            echo "âŒ No cluster VPCs found for $CLUSTER_ID" >&2
        fi
        # Output empty JSON structure
        cat << EOF
{
    "REGION": "$REGION",
    "EC2_INSTANCES": [],
    "EBS_VOLUMES": [],
    "EBS_SNAPSHOTS": [],
    "APPLICATION_LOAD_BALANCERS": [],
    "CLASSIC_LOAD_BALANCERS": [],
    "TARGET_GROUPS": [],
    "AUTO_SCALING_GROUPS": [],
    "LAUNCH_TEMPLATES": [],
    "VPCS": [],
    "SUBNETS": [],
    "INTERNET_GATEWAYS": [],
    "NAT_GATEWAYS": [],
    "ROUTE_TABLES": [],
    "SECURITY_GROUPS": [],
    "NETWORK_ACLS": [],
    "NETWORK_INTERFACES": [],
    "VPC_ENDPOINTS": [],
    "ELASTIC_IPS": [],
    "EFS_FILE_SYSTEMS": [],
    "EFS_MOUNT_TARGETS": [],
    "RDS_INSTANCES": [],
    "RDS_CLUSTERS": [],
    "EKS_CLUSTERS": [],
    "ECR_REPOSITORIES": [],
    "CLOUDFORMATION_STACKS": [],
    "GLOBAL_IAM_RESOURCES": {
        "IAM_ROLES": [],
        "IAM_POLICIES": [],
        "IAM_INSTANCE_PROFILES": []
    }
}
EOF
        return
    fi
    
    verbose_log "Found cluster VPCs: $cluster_vpcs"
    
    # Step 2: Find global resources by cluster tags
    local iam_roles iam_policies s3_buckets
    iam_roles=$(find_cluster_iam_roles "$CLUSTER_ID")
    iam_policies=$(find_cluster_iam_policies "$CLUSTER_ID") 
    
    # Step 3: Follow VPC relationships to find all VPC-scoped resources
    local subnets security_groups route_tables internet_gateways nat_gateways vpc_endpoints
    local classic_elbs application_elbs
    
    subnets=$(find_subnets_in_vpcs "$cluster_vpcs" "$REGION")
    security_groups=$(find_security_groups_in_vpcs "$cluster_vpcs" "$REGION") 
    route_tables=$(find_route_tables_in_vpcs "$cluster_vpcs" "$REGION")
    internet_gateways=$(find_internet_gateways_for_vpcs "$cluster_vpcs" "$REGION")
    nat_gateways=$(find_nat_gateways_in_vpcs "$cluster_vpcs" "$REGION")
    vpc_endpoints=$(find_vpc_endpoints_in_vpcs "$cluster_vpcs" "$REGION")
    classic_elbs=$(find_classic_elbs_in_vpcs "$cluster_vpcs" "$REGION")
    application_elbs=$(find_application_elbs_in_vpcs "$cluster_vpcs" "$REGION")
    
    # Step 4: Follow subnet relationships to find subnet-deployed resources
    local network_interfaces ec2_instances rds_instances efs_mount_targets
    
    network_interfaces=$(find_network_interfaces_in_subnets "$subnets" "$REGION")
    ec2_instances=$(find_ec2_instances_in_subnets "$subnets" "$REGION") 
    rds_instances=$(find_rds_instances_in_subnets "$subnets" "$REGION")
    efs_mount_targets=$(find_efs_mount_targets_in_subnets "$subnets" "$REGION")
    
    # Step 5: Follow instance relationships to find attached resources  
    local ebs_volumes ebs_snapshots elastic_ips auto_scaling_groups
    ebs_volumes=$(find_ebs_volumes_for_instances "$ec2_instances" "$REGION")
    ebs_snapshots=$(find_ebs_snapshots_for_volumes "$ebs_volumes" "$REGION")
    elastic_ips=$(find_elastic_ips_for_instances "$ec2_instances" "$network_interfaces" "$REGION")
    auto_scaling_groups=$(find_auto_scaling_groups_for_instances "$ec2_instances" "$REGION")
    
    # Step 6: Follow service relationships to find service-created resources
    local target_groups launch_templates efs_filesystems cloudformation_stacks ecr_repositories
    target_groups=$(find_target_groups_for_elbs "$application_elbs" "$REGION")
    launch_templates=$(find_launch_templates_for_asgs "$auto_scaling_groups" "$REGION")
    efs_filesystems=$(find_efs_filesystems_for_mount_targets "$efs_mount_targets" "$REGION")
    cloudformation_stacks=$(find_cloudformation_stacks_for_cluster "$CLUSTER_ID" "$REGION")
    ecr_repositories=$(find_ecr_repositories_for_cluster "$CLUSTER_ID" "$REGION")
    
    # Ensure all variables have valid JSON (replace empty with [])
    [[ -z "$target_groups" || "$target_groups" == "" ]] && target_groups="[]"
    [[ -z "$launch_templates" || "$launch_templates" == "" ]] && launch_templates="[]"
    [[ -z "$efs_filesystems" || "$efs_filesystems" == "" ]] && efs_filesystems="[]" 
    [[ -z "$ebs_volumes" || "$ebs_volumes" == "" ]] && ebs_volumes="[]"
    [[ -z "$ebs_snapshots" || "$ebs_snapshots" == "" ]] && ebs_snapshots="[]"
    [[ -z "$ec2_instances" || "$ec2_instances" == "" ]] && ec2_instances="[]"
    [[ -z "$rds_instances" || "$rds_instances" == "" ]] && rds_instances="[]"
    [[ -z "$efs_mount_targets" || "$efs_mount_targets" == "" ]] && efs_mount_targets="[]"
    [[ -z "$network_interfaces" || "$network_interfaces" == "" ]] && network_interfaces="[]"
    [[ -z "$auto_scaling_groups" || "$auto_scaling_groups" == "" ]] && auto_scaling_groups="[]"
    [[ -z "$cloudformation_stacks" || "$cloudformation_stacks" == "" ]] && cloudformation_stacks="[]"
    [[ -z "$ecr_repositories" || "$ecr_repositories" == "" ]] && ecr_repositories="[]"
    
    # Convert VPCs to expected format
    local vpcs_json
    vpcs_json=$(echo "$cluster_vpcs" | tr ' ' '\n' | jq -R . | jq -s . | jq 'map([., "10.0.0.0/16", "available", false, "relationship-discovered"])')
    
    # Step 7: Output in aws-clean-resources compatible format
    cat << EOF
{
    "REGION": "$REGION",
    "EC2_INSTANCES": $ec2_instances,
    "EBS_VOLUMES": $ebs_volumes,
    "EBS_SNAPSHOTS": $ebs_snapshots,
    "APPLICATION_LOAD_BALANCERS": $application_elbs,
    "CLASSIC_LOAD_BALANCERS": $classic_elbs,
    "TARGET_GROUPS": $target_groups,
    "AUTO_SCALING_GROUPS": $auto_scaling_groups,
    "LAUNCH_TEMPLATES": $launch_templates,
    "VPCS": $vpcs_json,
    "SUBNETS": $subnets,
    "INTERNET_GATEWAYS": $internet_gateways,
    "NAT_GATEWAYS": $nat_gateways,
    "ROUTE_TABLES": $route_tables,
    "SECURITY_GROUPS": $security_groups,
    "NETWORK_ACLS": [],
    "NETWORK_INTERFACES": $network_interfaces,
    "VPC_ENDPOINTS": $vpc_endpoints,
    "ELASTIC_IPS": $elastic_ips,
    "EFS_FILE_SYSTEMS": $efs_filesystems,
    "EFS_MOUNT_TARGETS": $efs_mount_targets,
    "RDS_INSTANCES": $rds_instances,
    "RDS_CLUSTERS": [],
    "EKS_CLUSTERS": [],
    "ECR_REPOSITORIES": $ecr_repositories,
    "CLOUDFORMATION_STACKS": $cloudformation_stacks,
    "GLOBAL_IAM_RESOURCES": {
        "IAM_ROLES": $iam_roles,
        "IAM_POLICIES": $iam_policies,
        "IAM_INSTANCE_PROFILES": $iam_policies
    }
}
EOF

    if [[ "$VERBOSE" == "true" ]]; then
        echo "" >&2
        echo "âœ… Comprehensive relationship discovery complete!" >&2
        echo "Found resources:" >&2
        echo "  VPCs: $(echo "$cluster_vpcs" | wc -w)" >&2
        echo "  Subnets: $(echo "$subnets" | jq 'length')" >&2
        echo "  Security Groups: $(echo "$security_groups" | jq 'length')" >&2
        echo "  EC2 Instances: $(echo "$ec2_instances" | jq 'length')" >&2
        echo "  Load Balancers: $(($(echo "$classic_elbs" | jq 'length') + $(echo "$application_elbs" | jq 'length')))" >&2
        echo "  Network Interfaces: $(echo "$network_interfaces" | jq 'length')" >&2
        echo "  EBS Volumes: $(echo "$ebs_volumes" | jq 'length')" >&2
        echo "" >&2
        echo "ðŸ’¡ All resources discovered through relationship following - no orphaned resources missed!" >&2
    fi
}

debug_log "Script started with args: $*"
main "$@"
debug_log "Script completed successfully"